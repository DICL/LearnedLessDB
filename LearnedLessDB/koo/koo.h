#pragma once
#include <iostream>
#include <chrono>
#include <math.h>
#include <fstream>
#include <atomic>
#include <thread>
#include <set>
#include <unordered_set>
#include <unordered_map>
#include <unistd.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <experimental/filesystem>
#include <map>
#include <ctime>
#include <cmath>
#include <mutex>
#include <condition_variable>

#define YCSB_WRAPPER 1		// produce requests before run workloads + skip writing latency files
#define YCSB_THROUGHPUTHIST 0	// record throughput history (no latency)
#define YCSB_COPYDB 1			// SpanDB ycsb load 외 워크로드 전 db copy -> copy한 db에서 워크로드 실험
#define YCSB_SOSD 0		// records=600M

#define MULTI_COMPACTION 1

#define LEARN 1
#define NORMARLIZE_KEY 0		// key - min_key. 선분 k, b만

#define MERGE 1
#define SKIP_SEG 30			// default. merge_new.cc
#define OPT1 1									// Compaction 내 Compare() 횟수 1/n으로 줄여보자	TODO

#define MODEL_COMPACTION 1		// compaction using merged models

#define RETRAIN 1
#define RETRAIN2 1						// 재학습 대신 error bound 확장
#define RETRAIN3 1						// 재학습하는 파일은 우선순위 낮게

#define SST_LIFESPAN 0	// level별 SST의 lifespan. table 생성(T) -> model 생성(M) -> model 사용(U)
#define AC_TEST 0
#define AC_TEST2 0		// retrainig threshold test
#define TIME_W 0
#define TIME_R 0
#define TIME_R_LEVEL 0
#define MODELCOMP_TEST 0
#define MODEL_BREAKDOWN 0
#define MODEL_ACCURACY 0			// WriteModel시 TestModelAccuracy()
#define LOOKUP_ACCURACY 0

namespace koo {

extern std::string model_dbname;
extern double learn_model_error;
extern double merge_model_error;

#if LOOKUP_ACCURACY
extern std::atomic<uint64_t> lm_error[7];
extern std::atomic<uint64_t> lm_num_error[7];
extern std::atomic<uint64_t> mm_error[7];
extern std::atomic<uint64_t> mm_num_error[7];
extern std::atomic<uint64_t> rm_error[7];
extern std::atomic<uint64_t> rm_num_error[7];
#endif

#if MODEL_ACCURACY
extern std::atomic<uint64_t> lm_max_error[7];
extern std::atomic<uint64_t> lm_avg_error[7];
extern std::atomic<uint64_t> lm_num_error2[7];
extern std::atomic<uint64_t> mm_max_error[7];
extern std::atomic<uint64_t> mm_avg_error[7];
extern std::atomic<uint64_t> mm_num_error2[7];

extern std::atomic<uint64_t> mm_max_error_over[7];
extern std::atomic<uint64_t> mm_avg_error_over[7];
extern std::atomic<uint64_t> mm_num_error_over[7];
extern std::atomic<uint64_t> mm_cnt_overmax[7];
#endif

#if MODEL_BREAKDOWN
extern std::atomic<uint64_t> lm_segs[7];	// learned model # of segs
extern std::atomic<uint64_t> lm_keys[7];	// learned model # of keys
extern std::atomic<uint64_t> lm_num[7];
extern std::atomic<uint64_t> mm_segs[7];	// merged model
extern std::atomic<uint64_t> mm_keys[7];	// merged model
extern std::atomic<uint64_t> mm_num[7];

extern uint64_t num_lm[7];		// # of learned models
extern uint64_t num_mm[7];		// # of merged models
#endif

class SpinLock {
 public:
  SpinLock() : flag_(false){}
  void lock() {
  	bool expect = false;
  	while (!flag_.compare_exchange_weak(expect, true)){
  		expect = false;
		}
	}
	void unlock(){
		flag_.store(false);
	}

 private:
  std::atomic<bool> flag_;
};

class RWLock {
 public:
	void LockWrite() {
		while (writer_active.exchange(true, std::memory_order_acquire)) {}
		while (reader_count.load(std::memory_order_acquire) > 0) {
			std::this_thread::yield();
		}
	}
	void UnlockWrite() {
		writer_active.store(false, std::memory_order_release);
	}
	void LockRead() {
		while (true) {
			while (writer_active.load(std::memory_order_acquire)) {
				std::this_thread::yield();
			}
			reader_count.fetch_add(1, std::memory_order_acquire);
			if (!writer_active.load(std::memory_order_acquire)) break;
			reader_count.fetch_sub(1, std::memory_order_release);
		}
	}
	void UnlockRead() {
		reader_count.fetch_sub(1, std::memory_order_release);
	}

 private:
	std::atomic<int> reader_count{0};
	std::atomic<bool> writer_active{false};
};

#if SST_LIFESPAN
struct FileLifespanData {
	bool learned;
	bool merged;
	uint32_t level;
	uint64_t T_start;		// table building started
	uint64_t T_end;			// ~ table building finished (LogAndApply)
	uint64_t W_end;			// ~ waiting for model building
	uint64_t M_end;			// ~ model building finished
	uint64_t U_end;			// ~ table deleted

	FileLifespanData() : learned(false), merged(false), level(0), T_start(0), T_end(0), W_end(0), M_end(0), U_end(0) {}

	FileLifespanData(uint32_t level_, uint64_t T_start_)
		: learned(false), merged(false), level(level_), T_start(T_start_), T_end(0), W_end(0), M_end(0), U_end(0) {}
};

struct hash_FileLifespanData {
	size_t operator()(const uint64_t &file_number) const {
		return file_number;
	}
};

extern std::mutex mutex_lifespan_;
extern std::unordered_map<uint64_t, FileLifespanData, hash_FileLifespanData> lifespans;		// <file_number, >
#endif

#if AC_TEST
extern uint64_t num_files_flush;			// # of files generated by flush
extern uint64_t num_files_compaction;
extern uint64_t num_learned;
extern uint64_t num_merged;
extern uint64_t num_retrained;
extern std::atomic<uint32_t> num_tryretraining;
#if RETRAIN2
extern std::atomic<uint32_t> num_erroradded;
#endif
extern std::atomic<uint64_t> file_size[7];		// file size per level
extern std::atomic<uint64_t> num_files[7];
#endif

#if AC_TEST2
struct alignas(64) PaddedAtomic {
	std::atomic<uint64_t> val;
};

extern PaddedAtomic served_i_time[6];
extern PaddedAtomic served_i[6];			// index block (L0-L5)
extern PaddedAtomic served_l_time[6];
extern PaddedAtomic served_l[6];			// learned model (L0-L5)
extern PaddedAtomic served_m_time[4];
extern PaddedAtomic served_m[4];			// merged model (L2-L5)
extern PaddedAtomic served_r_time[4];
extern PaddedAtomic served_r[4];			// retrained model (L2-L5)

extern std::atomic<uint32_t> merged_model_miss;
extern std::atomic<uint32_t> served_m_linear;			// merged model linear search
extern std::atomic<uint32_t> served_m_linear_fail;			// merged model linear search

extern std::atomic<uint64_t> linear_time;
extern std::atomic<uint32_t> linear_num;
#endif

#if TIME_W
extern uint64_t learntime;
extern uint32_t num_learntime;
extern uint64_t mergetime;
extern uint32_t num_mergetime;
//extern uint64_t compactiontime[2][5];
//extern uint32_t num_compactiontime[2][5];
extern uint64_t compactiontime2[2][7];
extern uint32_t num_compactiontime2[2][7];
extern uint64_t learntime_l0;
extern uint32_t num_learntime_l0;
extern uint64_t learn_bytesize;
extern uint32_t num_learn_bytesize;
extern uint64_t merge_bytesize;
extern uint32_t num_merge_bytesize;

extern uint64_t learn_size;
extern uint32_t num_learn_size;
extern uint64_t merge_size;
extern uint32_t num_merge_size;

extern int64_t size_inputs[2][7];
extern int64_t size_outputs[2][7];
extern uint32_t num_inputs[2][7];
extern uint32_t num_outputs[2][7];
#endif

#if TIME_R
extern std::atomic<uint32_t> num_i_path;			// # of index block path
extern std::atomic<uint32_t> num_l_path;			// # of learned model path
extern std::atomic<uint32_t> num_m_path;			// # of merged model path
extern std::atomic<uint64_t> i_path;			// total time of index block path
extern std::atomic<uint64_t> l_path;			// total time of learned model path
extern std::atomic<uint64_t> m_path;			// total time of merged model path
#endif
#if TIME_R_LEVEL
extern std::atomic<uint32_t> num_i_path_l[7];
extern std::atomic<uint32_t> num_l_path_l[7];
extern std::atomic<uint32_t> num_m_path_l[7];
extern std::atomic<uint64_t> i_path_l[7];
extern std::atomic<uint64_t> l_path_l[7];
extern std::atomic<uint64_t> m_path_l[7];
#endif

#if MODELCOMP_TEST
extern std::atomic<uint64_t> num_inserts[2];
extern std::atomic<uint64_t> num_comparisons[2];
extern std::atomic<uint64_t> num_keys_lower[2];
extern std::atomic<uint64_t> num_keys_upper[2];
extern std::atomic<uint64_t> total_num_keys[2];

/*extern std::atomic<uint64_t> total_cpu_cycles[2];
extern std::atomic<uint32_t> num_cpu_cycles[2];
extern uint64_t rdtsc_start();
extern uint64_t rdtsc_end();*/
#endif

extern void Report();
extern void Reset();

}
